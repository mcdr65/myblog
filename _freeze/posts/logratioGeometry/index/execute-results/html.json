{
  "hash": "e2729c16f667697c438afd8924627dda",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Compositions\"\ndate: \"2022-11-03\"\ndescription: \"Simplex as sample space: Tetrahedron for 4-part compositions\"\ncategories: [code, analysis]\n---\n\n\n\n\n###### Sample space of compositional data ######\n\nThe sample space of compositional data with $D$ parts is a simplex $\\mathcal{S}^D$ of dimension $D-1$: \n\n$\\mathcal{S}^D=\\{\\mathbf{x}=[x_1,x_2,\\dots,x_D]\\in \\mathbb{R}^D \\mid\nx_i>0, i=1,2,\\dots,D; \\sum_{i=1}^Dx_i=\\mathcal{k}\\}$\n\nThe only information is given by the *ratios between components*, so\nthe information of a composition is preserved under multiplication by\nany positive constant. Therefore, the sample space of compositional\ndata can always be assumed to be a standard simplex, i.e. $\\mathcal{k}\n= 1$.\n\nNormalization to the standard simplex is called closure and is\n\n$\\mathcal{C}[x_1,x_2,\\dots,x_D]=\\left[\\frac{x_1}{\\sum_{i=1}^D x_i},\\frac{x_2}{\\sum_{i=1}^D x_i}, \\dots,\\frac{x_D}{\\sum_{i=1}^D x_i}\\right]$\n\n\n###### Example ######\n\n4 Raters rated a 4-part-composition on $n=20$ subjects. See the interactive *Tetrahedron*\n\n\n\n\n\n\n::: {.cell .column-page webgl='true'}\n\n```{.r .cell-code}\nplot3D(datAitch,col=as.numeric(Rater),size=5,axes=TRUE,coors=TRUE)\n```\n\n```{=html}\n<div id=\"rgl40090\" style=\"width:100%;height:464px;\" class=\"rglWebGL html-widget\" role=\"img\" aria-labelledby=\"rgl40090-aria\"></div>\n<script type=\"application/json\" data-for=\"rgl40090\">{\"x\":{\"material\":{\"color\":\"#000000\",\"alpha\":1,\"lit\":true,\"ambient\":\"#000000\",\"specular\":\"#FFFFFF\",\"emission\":\"#000000\",\"shininess\":50,\"smooth\":true,\"front\":\"filled\",\"back\":\"filled\",\"size\":3,\"lwd\":1,\"fog\":true,\"point_antialias\":false,\"line_antialias\":false,\"texture\":null,\"textype\":\"rgb\",\"texmode\":\"modulate\",\"texmipmap\":false,\"texminfilter\":\"linear\",\"texmagfilter\":\"linear\",\"texenvmap\":false,\"depth_mask\":true,\"depth_test\":\"less\",\"isTransparent\":false,\"polygon_offset\":[0,0],\"margin\":\"\",\"floating\":false,\"tag\":\"\",\"blend\":[\"src_alpha\",\"one_minus_src_alpha\"]},\"rootSubscene\":1,\"objects\":{\"7\":{\"id\":7,\"type\":\"linestrip\",\"material\":{\"lit\":false,\"size\":2},\"vertices\":\"0\",\"colors\":\"1\",\"centers\":\"2\",\"ignoreExtent\":false,\"flags\":32832},\"8\":{\"id\":8,\"type\":\"points\",\"material\":{\"lit\":false,\"size\":5},\"vertices\":\"3\",\"colors\":\"4\",\"centers\":\"5\",\"ignoreExtent\":false,\"flags\":34816},\"9\":{\"id\":9,\"type\":\"text\",\"material\":{\"lit\":false},\"vertices\":\"6\",\"colors\":\"7\",\"texts\":[[\"peripheral\"],[\"central\"],[\"cortical\"],[\"vegetative\"]],\"cex\":[[1]],\"adj\":[[0.5,0.5,0.5]],\"centers\":\"8\",\"family\":[[\"sans\"]],\"font\":[[1]],\"ignoreExtent\":false,\"flags\":33808},\"5\":{\"id\":5,\"type\":\"light\",\"vertices\":[[0,0,1]],\"colors\":[[1,1,1,1],[1,1,1,1],[1,1,1,1]],\"viewpoint\":true,\"finite\":false},\"4\":{\"id\":4,\"type\":\"background\",\"material\":{},\"colors\":\"9\",\"centers\":\"10\",\"sphere\":false,\"fogtype\":\"none\",\"fogscale\":1,\"flags\":32768},\"6\":{\"id\":6,\"type\":\"background\",\"material\":{\"lit\":false,\"back\":\"lines\"},\"colors\":\"11\",\"centers\":\"12\",\"sphere\":false,\"fogtype\":\"none\",\"fogscale\":1,\"flags\":32768},\"1\":{\"id\":1,\"type\":\"subscene\",\"par3d\":{\"antialias\":8,\"FOV\":30,\"ignoreExtent\":false,\"listeners\":1,\"mouseMode\":{\"none\":\"none\",\"left\":\"trackball\",\"right\":\"zoom\",\"middle\":\"fov\",\"wheel\":\"pull\"},\"observer\":[0,0,4.247145175933838],\"modelMatrix\":[[1,0,0,0],[0,1,0,-0.2041241526603699],[0,0,1,-4.535820484161377],[0,0,0,1]],\"projMatrix\":[[3.732050657272339,0,0,0],[0,3.732050657272339,0,0],[0,0,-3.86370325088501,-15.31046581268311],[0,0,-1,0]],\"skipRedraw\":false,\"userMatrix\":[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]],\"userProjection\":[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]],\"scale\":[1,1,1],\"viewport\":{\"x\":0,\"y\":0,\"width\":1,\"height\":1},\"zoom\":1,\"bbox\":[-0.7071067690849304,0.7071067690849304,-0.4082483053207397,0.8164966106414795,-0.2886751294136047,0.8660253882408142],\"windowRect\":[0,0,256,256],\"family\":\"sans\",\"font\":1,\"cex\":1,\"useFreeType\":true,\"fontname\":\"NULL\",\"maxClipPlanes\":2147483647,\"glVersion\":\"NA\",\"activeSubscene\":0},\"embeddings\":{\"viewport\":\"replace\",\"projection\":\"replace\",\"model\":\"replace\",\"mouse\":\"replace\"},\"objects\":[6,7,8,9,5],\"subscenes\":[],\"flags\":36176}},\"crosstalk\":{\"key\":[],\"group\":[],\"id\":[],\"options\":[]},\"width\":672,\"height\":480,\"buffer\":{\"accessors\":[{\"bufferView\":0,\"componentType\":5126,\"count\":8,\"type\":\"VEC3\"},{\"bufferView\":1,\"componentType\":5126,\"count\":1,\"type\":\"VEC4\"},{\"bufferView\":2,\"componentType\":5126,\"count\":8,\"type\":\"VEC3\"},{\"bufferView\":3,\"componentType\":5126,\"count\":80,\"type\":\"VEC3\"},{\"bufferView\":4,\"componentType\":5121,\"count\":80,\"type\":\"VEC4\",\"normalized\":true},{\"bufferView\":5,\"componentType\":5126,\"count\":80,\"type\":\"VEC3\"},{\"bufferView\":6,\"componentType\":5126,\"count\":4,\"type\":\"VEC3\"},{\"bufferView\":7,\"componentType\":5126,\"count\":1,\"type\":\"VEC4\"},{\"bufferView\":8,\"componentType\":5126,\"count\":4,\"type\":\"VEC3\"},{\"bufferView\":9,\"componentType\":5126,\"count\":1,\"type\":\"VEC4\"},{\"bufferView\":10,\"componentType\":5121,\"count\":1,\"type\":\"VEC3\"},{\"bufferView\":11,\"componentType\":5121,\"count\":1,\"type\":\"VEC4\"},{\"bufferView\":12,\"componentType\":5121,\"count\":1,\"type\":\"VEC3\"}],\"bufferViews\":[{\"buffer\":0,\"byteLength\":96,\"byteOffset\":0},{\"buffer\":0,\"byteLength\":16,\"byteOffset\":96},{\"buffer\":0,\"byteLength\":96,\"byteOffset\":112},{\"buffer\":0,\"byteLength\":960,\"byteOffset\":208},{\"buffer\":0,\"byteLength\":320,\"byteOffset\":1168},{\"buffer\":0,\"byteLength\":960,\"byteOffset\":1488},{\"buffer\":0,\"byteLength\":48,\"byteOffset\":2448},{\"buffer\":0,\"byteLength\":16,\"byteOffset\":2496},{\"buffer\":0,\"byteLength\":48,\"byteOffset\":2512},{\"buffer\":0,\"byteLength\":16,\"byteOffset\":2560},{\"buffer\":0,\"byteLength\":3,\"byteOffset\":2576},{\"buffer\":0,\"byteLength\":4,\"byteOffset\":2579},{\"buffer\":0,\"byteLength\":3,\"byteOffset\":2583}],\"buffers\":[{\"byteLength\":2586,\"bytes\":\"8wQ1v+wF0b46zZO+8wQ1P+wF0b46zZO+AAAAAOwFUT86zZO+AAAAAAAAAADXs10/8wQ1v+wF\\n0b46zZO+AAAAAOwFUT86zZO+8wQ1P+wF0b46zZO+AAAAAAAAAADXs10/v74+P7++Pj+/vj4/\\nAACAP/MENb/sBdG+Os2TvvMENT/sBdG+Os2TvgAAAADsBVE/Os2TvgAAAAAAAAAA17NdP/ME\\nNb/sBdG+Os2TvgAAAADsBVE/Os2TvvMENT/sBdG+Os2TvgAAAAAAAAAA17NdP8PQkD2Gqcg8\\nm9VUvsPQkD3n0/o9rFwxvsPQED1xxJw+rFwxvsPQED7wNye9kHtsPSQ5WT7wN6c9kHtsPiQ5\\n2T1xxJw+rFwxvlDHrb1ZxgW9QPqHvgAAAAAAAAAArFwxPsPQkD3n0/o9rFwxPsPQED3yUBK+\\nkHtsvcPQEL3n03q9rFwxviQ52T7wNye9kHvsvQAAAADwN6c9kHvsvcPQEL3p7GU+kHtsviQ5\\nWT7wNye9Os2TvsPQED4AAMCjrFwxvsPQEL1z3Ye+kHtsvvMENT7wN6e8kHtsvgAAAADn0/o+\\nrFwxPsPQkD7n0/o9AACAosPQkD0AAAAArFwxvsPQkD7wN6c9Os2TvgAAAADwNyc+Os2TPiQ5\\n2T7wNye+kHtsPVRtfT7wN6c8kHtsPcPQkD7n03o+rFwxvsPQED3sBdE9kHtsvcPQkL7wNye+\\nkHtsPcPQkD3n0/o9rFwxPsPQED1z3Yc+kHtsPQAAAADyUJI+kHvsPdvqoj7sBdE9kHtsvvME\\nNT7yUBI+kHtsPcPQED7yUJI+kHtsviQ52T3sBdE9kHtsvsPQED4AAMCjrFwxvsPQED7wNye+\\nOs2Tvtvqoj7n03o9rFwxvgAAAADsBdE+kHvsPfMENT7yUBI+kHtsPQAAAABZxgU8Os2TviQ5\\nWb7yUJK+Os2TvsPQkD3sBVE+kHtsPSQ52T3uHjy+AAAAo8PQkD7n03o+rFwxvsPQED7wNye+\\nOs2TvvMEtT7wNyc9kHtsvSQ5WT7wNye9kHtsPWq0Z7wcG2q9Os2TPsPQkL3sBVE+HuzOPq2J\\nJr6IwjM+oQJJvvMEtT7wNye9kHtsPdvqor7sBdE9kHtsvvMEtT7wNye9Os2TviJmsT6EkF0+\\nOs2TvsPQkD4AAAAArFwxvsWjuD5Te0Q+Os2TviQ52T7wN6c9Os2TvgAAAADp7OU+kHtsPlRt\\nfT7sBdE9kHtsvcPQkD4cG2o9somlvVDHLT7sBVE+somlvZdCvD2/Io49soklPk70hT6Cd/K9\\nkHvsPbEv9j2IwjO+oQJJPvMENT7p7GU+kHtsvZkV5D63vuG9veMNvlDHrT278Le9kHtsPpdC\\nvL278De9KUa3PglMnz0gTcA9oQJJPlDHrbzuHjw+veMNPVRtfT6K2569py+9PAlMnz1xxJw+\\nAAAAAMPQkD3n03o+m9XUvSQ52b1XrRq+lqhgvlDHLT5ZxoU9py89PFDHLT0kfxa+m9XUvcPQ\\nkD7wN6e9kHtsvcPQEL1z3Yc+kHtsPlRtfT7wN6c8kHtsPQAAAP8AAAD/AAAA/wAAAP8AAAD/\\nAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAA\\nAP8AAAD/31Nr/99Ta//fU2v/31Nr/99Ta//fU2v/31Nr/99Ta//fU2v/31Nr/99Ta//fU2v/\\n31Nr/99Ta//fU2v/31Nr/99Ta//fU2v/31Nr/99Ta/9h0E//YdBP/2HQT/9h0E//YdBP/2HQ\\nT/9h0E//YdBP/2HQT/9h0E//YdBP/2HQT/9h0E//YdBP/2HQT/9h0E//YdBP/2HQT/9h0E//\\nYdBP/yKX5v8il+b/Ipfm/yKX5v8il+b/Ipfm/yKX5v8il+b/Ipfm/yKX5v8il+b/Ipfm/yKX\\n5v8il+b/Ipfm/yKX5v8il+b/Ipfm/yKX5v8il+b/w9CQPYapyDyb1VS+w9CQPefT+j2sXDG+\\nw9AQPXHEnD6sXDG+w9AQPvA3J72Qe2w9JDlZPvA3pz2Qe2w+JDnZPXHEnD6sXDG+UMetvVnG\\nBb1A+oe+AAAAAAAAAACsXDE+w9CQPefT+j2sXDE+w9AQPfJQEr6Qe2y9w9AQvefTer2sXDG+\\nJDnZPvA3J72Qe+y9AAAAAPA3pz2Qe+y9w9AQvensZT6Qe2y+JDlZPvA3J706zZO+w9AQPgAA\\nwKOsXDG+w9AQvXPdh76Qe2y+8wQ1PvA3p7yQe2y+AAAAAOfT+j6sXDE+w9CQPufT+j0AAICi\\nw9CQPQAAAACsXDG+w9CQPvA3pz06zZO+AAAAAPA3Jz46zZM+JDnZPvA3J76Qe2w9VG19PvA3\\npzyQe2w9w9CQPufTej6sXDG+w9AQPewF0T2Qe2y9w9CQvvA3J76Qe2w9w9CQPefT+j2sXDE+\\nw9AQPXPdhz6Qe2w9AAAAAPJQkj6Qe+w92+qiPuwF0T2Qe2y+8wQ1PvJQEj6Qe2w9w9AQPvJQ\\nkj6Qe2y+JDnZPewF0T2Qe2y+w9AQPgAAwKOsXDG+w9AQPvA3J746zZO+2+qiPufTej2sXDG+\\nAAAAAOwF0T6Qe+w98wQ1PvJQEj6Qe2w9AAAAAFnGBTw6zZO+JDlZvvJQkr46zZO+w9CQPewF\\nUT6Qe2w9JDnZPe4ePL4AAACjw9CQPufTej6sXDG+w9AQPvA3J746zZO+8wS1PvA3Jz2Qe2y9\\nJDlZPvA3J72Qe2w9arRnvBwbar06zZM+w9CQvewFUT4e7M4+rYkmvojCMz6hAkm+8wS1PvA3\\nJ72Qe2w92+qivuwF0T2Qe2y+8wS1PvA3J706zZO+ImaxPoSQXT46zZO+w9CQPgAAAACsXDG+\\nxaO4PlN7RD46zZO+JDnZPvA3pz06zZO+AAAAAOns5T6Qe2w+VG19PuwF0T2Qe2y9w9CQPhwb\\naj2yiaW9UMctPuwFUT6yiaW9l0K8Pb8ijj2yiSU+TvSFPoJ38r2Qe+w9sS/2PYjCM76hAkk+\\n8wQ1PunsZT6Qe2y9mRXkPre+4b294w2+UMetPbvwt72Qe2w+l0K8vbvwN70pRrc+CUyfPSBN\\nwD2hAkk+UMetvO4ePD694w09VG19Porbnr2nL708CUyfPXHEnD4AAAAAw9CQPefTej6b1dS9\\nJDnZvVetGr6WqGC+UMctPlnGhT2nLz08UMctPSR/Fr6b1dS9w9CQPvA3p72Qe2y9w9AQvXPd\\nhz6Qe2w+VG19PvA3pzyQe2w98wQ1v+wF0b46zZO+8wQ1P+wF0b46zZO+AAAAAOwFUT86zZO+\\nAAAAAAAAAADXs10/v74+P7++Pj+/vj4/AACAP/MENb/sBdG+Os2TvvMENT/sBdG+Os2TvgAA\\nAADsBVE/Os2TvgAAAAAAAAAA17NdP5mYmD6ZmJg+mZiYPgAAgD8AAAABAQEBAAAA\"}]},\"context\":{\"shiny\":false,\"rmarkdown\":null},\"vertexShader\":\"#line 2 1\\n// File 1 is the vertex shader\\n#ifdef GL_ES\\n#ifdef GL_FRAGMENT_PRECISION_HIGH\\nprecision highp float;\\n#else\\nprecision mediump float;\\n#endif\\n#endif\\n\\nattribute vec3 aPos;\\nattribute vec4 aCol;\\nuniform mat4 mvMatrix;\\nuniform mat4 prMatrix;\\nvarying vec4 vCol;\\nvarying vec4 vPosition;\\n\\n#ifdef NEEDS_VNORMAL\\nattribute vec3 aNorm;\\nuniform mat4 normMatrix;\\nvarying vec4 vNormal;\\n#endif\\n\\n#if defined(HAS_TEXTURE) || defined (IS_TEXT)\\nattribute vec2 aTexcoord;\\nvarying vec2 vTexcoord;\\n#endif\\n\\n#ifdef FIXED_SIZE\\nuniform vec3 textScale;\\n#endif\\n\\n#ifdef FIXED_QUADS\\nattribute vec3 aOfs;\\n#endif\\n\\n#ifdef IS_TWOSIDED\\n#ifdef HAS_NORMALS\\nvarying float normz;\\nuniform mat4 invPrMatrix;\\n#else\\nattribute vec3 aPos1;\\nattribute vec3 aPos2;\\nvarying float normz;\\n#endif\\n#endif // IS_TWOSIDED\\n\\n#ifdef FAT_LINES\\nattribute vec3 aNext;\\nattribute vec2 aPoint;\\nvarying vec2 vPoint;\\nvarying float vLength;\\nuniform float uAspect;\\nuniform float uLwd;\\n#endif\\n\\n#ifdef USE_ENVMAP\\nvarying vec3 vReflection;\\n#endif\\n\\nvoid main(void) {\\n  \\n#ifndef IS_BRUSH\\n#if defined(NCLIPPLANES) || !defined(FIXED_QUADS) || defined(HAS_FOG) || defined(USE_ENVMAP)\\n  vPosition = mvMatrix * vec4(aPos, 1.);\\n#endif\\n  \\n#ifndef FIXED_QUADS\\n  gl_Position = prMatrix * vPosition;\\n#endif\\n#endif // !IS_BRUSH\\n  \\n#ifdef IS_POINTS\\n  gl_PointSize = POINTSIZE;\\n#endif\\n  \\n  vCol = aCol;\\n  \\n// USE_ENVMAP implies NEEDS_VNORMAL\\n\\n#ifdef NEEDS_VNORMAL\\n  vNormal = normMatrix * vec4(-aNorm, dot(aNorm, aPos));\\n#endif\\n\\n#ifdef USE_ENVMAP\\n  vReflection = normalize(reflect(vPosition.xyz/vPosition.w, \\n                        normalize(vNormal.xyz/vNormal.w)));\\n#endif\\n  \\n#ifdef IS_TWOSIDED\\n#ifdef HAS_NORMALS\\n  /* normz should be calculated *after* projection */\\n  normz = (invPrMatrix*vNormal).z;\\n#else\\n  vec4 pos1 = prMatrix*(mvMatrix*vec4(aPos1, 1.));\\n  pos1 = pos1/pos1.w - gl_Position/gl_Position.w;\\n  vec4 pos2 = prMatrix*(mvMatrix*vec4(aPos2, 1.));\\n  pos2 = pos2/pos2.w - gl_Position/gl_Position.w;\\n  normz = pos1.x*pos2.y - pos1.y*pos2.x;\\n#endif\\n#endif // IS_TWOSIDED\\n  \\n#ifdef NEEDS_VNORMAL\\n  vNormal = vec4(normalize(vNormal.xyz), 1);\\n#endif\\n  \\n#if defined(HAS_TEXTURE) || defined(IS_TEXT)\\n  vTexcoord = aTexcoord;\\n#endif\\n  \\n#if defined(FIXED_SIZE) && !defined(ROTATING)\\n  vec4 pos = prMatrix * mvMatrix * vec4(aPos, 1.);\\n  pos = pos/pos.w;\\n  gl_Position = pos + vec4(aOfs*textScale, 0.);\\n#endif\\n  \\n#if defined(IS_SPRITES) && !defined(FIXED_SIZE)\\n  vec4 pos = mvMatrix * vec4(aPos, 1.);\\n  pos = pos/pos.w + vec4(aOfs,  0.);\\n  gl_Position = prMatrix*pos;\\n#endif\\n  \\n#ifdef FAT_LINES\\n  /* This code was inspired by Matt Deslauriers' code in \\n   https://mattdesl.svbtle.com/drawing-lines-is-hard */\\n  vec2 aspectVec = vec2(uAspect, 1.0);\\n  mat4 projViewModel = prMatrix * mvMatrix;\\n  vec4 currentProjected = projViewModel * vec4(aPos, 1.0);\\n  currentProjected = currentProjected/currentProjected.w;\\n  vec4 nextProjected = projViewModel * vec4(aNext, 1.0);\\n  vec2 currentScreen = currentProjected.xy * aspectVec;\\n  vec2 nextScreen = (nextProjected.xy / nextProjected.w) * aspectVec;\\n  float len = uLwd;\\n  vec2 dir = vec2(1.0, 0.0);\\n  vPoint = aPoint;\\n  vLength = length(nextScreen - currentScreen)/2.0;\\n  vLength = vLength/(vLength + len);\\n  if (vLength > 0.0) {\\n    dir = normalize(nextScreen - currentScreen);\\n  }\\n  vec2 normal = vec2(-dir.y, dir.x);\\n  dir.x /= uAspect;\\n  normal.x /= uAspect;\\n  vec4 offset = vec4(len*(normal*aPoint.x*aPoint.y - dir), 0.0, 0.0);\\n  gl_Position = currentProjected + offset;\\n#endif\\n  \\n#ifdef IS_BRUSH\\n  gl_Position = vec4(aPos, 1.);\\n#endif\\n}\",\"fragmentShader\":\"#line 2 2\\n// File 2 is the fragment shader\\n#ifdef GL_ES\\n#ifdef GL_FRAGMENT_PRECISION_HIGH\\nprecision highp float;\\n#else\\nprecision mediump float;\\n#endif\\n#endif\\nvarying vec4 vCol; // carries alpha\\nvarying vec4 vPosition;\\n#if defined(HAS_TEXTURE) || defined (IS_TEXT)\\nvarying vec2 vTexcoord;\\nuniform sampler2D uSampler;\\n#endif\\n\\n#ifdef HAS_FOG\\nuniform int uFogMode;\\nuniform vec3 uFogColor;\\nuniform vec4 uFogParms;\\n#endif\\n\\n#if defined(IS_LIT) && !defined(FIXED_QUADS)\\nvarying vec4 vNormal;\\n#endif\\n\\n#if NCLIPPLANES > 0\\nuniform vec4 vClipplane[NCLIPPLANES];\\n#endif\\n\\n#if NLIGHTS > 0\\nuniform mat4 mvMatrix;\\n#endif\\n\\n#ifdef IS_LIT\\nuniform vec3 emission;\\nuniform float shininess;\\n#if NLIGHTS > 0\\nuniform vec3 ambient[NLIGHTS];\\nuniform vec3 specular[NLIGHTS]; // light*material\\nuniform vec3 diffuse[NLIGHTS];\\nuniform vec3 lightDir[NLIGHTS];\\nuniform bool viewpoint[NLIGHTS];\\nuniform bool finite[NLIGHTS];\\n#endif\\n#endif // IS_LIT\\n\\n#ifdef IS_TWOSIDED\\nuniform bool front;\\nvarying float normz;\\n#endif\\n\\n#ifdef FAT_LINES\\nvarying vec2 vPoint;\\nvarying float vLength;\\n#endif\\n\\n#ifdef USE_ENVMAP\\nvarying vec3 vReflection;\\n#endif\\n\\nvoid main(void) {\\n  vec4 fragColor;\\n#ifdef FAT_LINES\\n  vec2 point = vPoint;\\n  bool neg = point.y < 0.0;\\n  point.y = neg ? (point.y + vLength)/(1.0 - vLength) :\\n                 -(point.y - vLength)/(1.0 - vLength);\\n#if defined(IS_TRANSPARENT) && defined(IS_LINESTRIP)\\n  if (neg && length(point) <= 1.0) discard;\\n#endif\\n  point.y = min(point.y, 0.0);\\n  if (length(point) > 1.0) discard;\\n#endif // FAT_LINES\\n  \\n#ifdef ROUND_POINTS\\n  vec2 coord = gl_PointCoord - vec2(0.5);\\n  if (length(coord) > 0.5) discard;\\n#endif\\n  \\n#if NCLIPPLANES > 0\\n  for (int i = 0; i < NCLIPPLANES; i++)\\n    if (dot(vPosition, vClipplane[i]) < 0.0) discard;\\n#endif\\n    \\n#ifdef FIXED_QUADS\\n    vec3 n = vec3(0., 0., 1.);\\n#elif defined(IS_LIT)\\n    vec3 n = normalize(vNormal.xyz);\\n#endif\\n    \\n#ifdef IS_TWOSIDED\\n    if ((normz <= 0.) != front) discard;\\n#endif\\n\\n#ifdef IS_LIT\\n    vec3 eye = normalize(-vPosition.xyz/vPosition.w);\\n    vec3 lightdir;\\n    vec4 colDiff;\\n    vec3 halfVec;\\n    vec4 lighteffect = vec4(emission, 0.);\\n    vec3 col;\\n    float nDotL;\\n#ifdef FIXED_QUADS\\n    n = -faceforward(n, n, eye);\\n#endif\\n    \\n#if NLIGHTS > 0\\n    // Simulate two-sided lighting\\n    if (n.z < 0.0)\\n      n = -n;\\n    for (int i=0;i<NLIGHTS;i++) {\\n      colDiff = vec4(vCol.rgb * diffuse[i], vCol.a);\\n      lightdir = lightDir[i];\\n      if (!viewpoint[i]) {\\n        if (finite[i]) {\\n          lightdir = (mvMatrix * vec4(lightdir, 1.)).xyz;\\n        } else {\\n          lightdir = (mvMatrix * vec4(lightdir, 0.)).xyz;\\n        }\\n      }\\n      if (!finite[i]) {\\n        halfVec = normalize(lightdir + eye);\\n      } else {\\n        lightdir = normalize(lightdir - vPosition.xyz/vPosition.w);\\n        halfVec = normalize(lightdir + eye);\\n      }\\n      col = ambient[i];\\n      nDotL = dot(n, lightdir);\\n      col = col + max(nDotL, 0.) * colDiff.rgb;\\n      col = col + pow(max(dot(halfVec, n), 0.), shininess) * specular[i];\\n      lighteffect = lighteffect + vec4(col, colDiff.a);\\n    }\\n#endif\\n    \\n#else // not IS_LIT\\n    vec4 colDiff = vCol;\\n    vec4 lighteffect = colDiff;\\n#endif\\n    \\n#ifdef IS_TEXT\\n    vec4 textureColor = lighteffect*texture2D(uSampler, vTexcoord);\\n#endif\\n    \\n#ifdef HAS_TEXTURE\\n\\n// These calculations use the definitions from \\n// https://docs.gl/gl3/glTexEnv\\n\\n#ifdef USE_ENVMAP\\n    float m = 2.0 * sqrt(dot(vReflection, vReflection) + 2.0*vReflection.z + 1.0);\\n    vec4 textureColor = texture2D(uSampler, vReflection.xy / m + vec2(0.5, 0.5));\\n#else\\n    vec4 textureColor = texture2D(uSampler, vTexcoord);\\n#endif\\n\\n#ifdef TEXTURE_rgb\\n\\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\\n    textureColor = vec4(textureColor.rgb, lighteffect.a);\\n#endif \\n\\n#ifdef TEXMODE_modulate\\n    textureColor = lighteffect*vec4(textureColor.rgb, 1.);\\n#endif\\n\\n#ifdef TEXMODE_blend\\n    textureColor = vec4((1. - textureColor.rgb) * lighteffect.rgb, lighteffect.a);\\n#endif\\n\\n#ifdef TEXMODE_add\\n    textureColor = vec4(lighteffect.rgb + textureColor.rgb, lighteffect.a);\\n#endif\\n\\n#endif //TEXTURE_rgb\\n        \\n#ifdef TEXTURE_rgba\\n\\n#ifdef TEXMODE_replace\\n// already done\\n#endif \\n\\n#ifdef TEXMODE_modulate\\n    textureColor = lighteffect*textureColor;\\n#endif\\n\\n#ifdef TEXMODE_decal\\n    textureColor = vec4((1. - textureColor.a)*lighteffect.rgb) +\\n                     textureColor.a*textureColor.rgb, \\n                     lighteffect.a);\\n#endif\\n\\n#ifdef TEXMODE_blend\\n    textureColor = vec4((1. - textureColor.rgb) * lighteffect.rgb,\\n                    lighteffect.a*textureColor.a);\\n#endif\\n\\n#ifdef TEXMODE_add\\n    textureColor = vec4(lighteffect.rgb + textureColor.rgb,\\n                    lighteffect.a*textureColor.a);\\n#endif\\n    \\n#endif //TEXTURE_rgba\\n    \\n#ifdef TEXTURE_alpha\\n    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\\n\\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\\n    textureColor = vec4(lighteffect.rgb, luminance);\\n#endif \\n\\n#if defined(TEXMODE_modulate) || defined(TEXMODE_blend) || defined(TEXMODE_add)\\n    textureColor = vec4(lighteffect.rgb, lighteffect.a*luminance);\\n#endif\\n \\n#endif // TEXTURE_alpha\\n    \\n// The TEXTURE_luminance values are not from that reference    \\n#ifdef TEXTURE_luminance\\n    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\\n\\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\\n    textureColor = vec4(luminance, luminance, luminance, lighteffect.a);\\n#endif \\n\\n#ifdef TEXMODE_modulate\\n    textureColor = vec4(luminance*lighteffect.rgb, lighteffect.a);\\n#endif\\n\\n#ifdef TEXMODE_blend\\n    textureColor = vec4((1. - luminance)*lighteffect.rgb,\\n                        lighteffect.a);\\n#endif\\n\\n#ifdef TEXMODE_add\\n    textureColor = vec4(luminance + lighteffect.rgb, lighteffect.a);\\n#endif\\n\\n#endif // TEXTURE_luminance\\n \\n    \\n#ifdef TEXTURE_luminance_alpha\\n    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\\n\\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\\n    textureColor = vec4(luminance, luminance, luminance, textureColor.a);\\n#endif \\n\\n#ifdef TEXMODE_modulate\\n    textureColor = vec4(luminance*lighteffect.rgb, \\n                        textureColor.a*lighteffect.a);\\n#endif\\n\\n#ifdef TEXMODE_blend\\n    textureColor = vec4((1. - luminance)*lighteffect.rgb,\\n                        textureColor.a*lighteffect.a);\\n#endif\\n\\n#ifdef TEXMODE_add\\n    textureColor = vec4(luminance + lighteffect.rgb, \\n                        textureColor.a*lighteffect.a);\\n\\n#endif\\n\\n#endif // TEXTURE_luminance_alpha\\n    \\n    fragColor = textureColor;\\n\\n#elif defined(IS_TEXT)\\n    if (textureColor.a < 0.1)\\n      discard;\\n    else\\n      fragColor = textureColor;\\n#else\\n    fragColor = lighteffect;\\n#endif // HAS_TEXTURE\\n    \\n#ifdef HAS_FOG\\n    // uFogParms elements: x = near, y = far, z = fogscale, w = (1-sin(FOV/2))/(1+sin(FOV/2))\\n    // In Exp and Exp2: use density = density/far\\n    // fogF will be the proportion of fog\\n    // Initialize it to the linear value\\n    float fogF;\\n    if (uFogMode > 0) {\\n      fogF = (uFogParms.y - vPosition.z/vPosition.w)/(uFogParms.y - uFogParms.x);\\n      if (uFogMode > 1)\\n        fogF = mix(uFogParms.w, 1.0, fogF);\\n      fogF = fogF*uFogParms.z;\\n      if (uFogMode == 2)\\n        fogF = 1.0 - exp(-fogF);\\n      // Docs are wrong: use (density*c)^2, not density*c^2\\n      // https://gitlab.freedesktop.org/mesa/mesa/-/blob/master/src/mesa/swrast/s_fog.c#L58\\n      else if (uFogMode == 3)\\n        fogF = 1.0 - exp(-fogF*fogF);\\n      fogF = clamp(fogF, 0.0, 1.0);\\n      gl_FragColor = vec4(mix(fragColor.rgb, uFogColor, fogF), fragColor.a);\\n    } else gl_FragColor = fragColor;\\n#else\\n    gl_FragColor = fragColor;\\n#endif // HAS_FOG\\n    \\n}\",\"players\":[],\"webGLoptions\":{\"preserveDrawingBuffer\":true}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../../site_libs/htmlwidgets-1.6.4/htmlwidgets.js\"></script>\n<script src=\"../../site_libs/rglWebGL-binding-1.3.1/rglWebGL.js\"></script>\n<link href=\"../../site_libs/rglwidgetClass-1.3.1/rgl.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/rglwidgetClass-1.3.1/rglClass.src.js\"></script>\n<script src=\"../../site_libs/rglwidgetClass-1.3.1/utils.src.js\"></script>\n<script src=\"../../site_libs/rglwidgetClass-1.3.1/buffer.src.js\"></script>\n<script src=\"../../site_libs/rglwidgetClass-1.3.1/subscenes.src.js\"></script>\n<script src=\"../../site_libs/rglwidgetClass-1.3.1/shaders.src.js\"></script>\n<script src=\"../../site_libs/rglwidgetClass-1.3.1/shadersrc.src.js\"></script>\n<script src=\"../../site_libs/rglwidgetClass-1.3.1/textures.src.js\"></script>\n<script src=\"../../site_libs/rglwidgetClass-1.3.1/projection.src.js\"></script>\n<script src=\"../../site_libs/rglwidgetClass-1.3.1/mouse.src.js\"></script>\n<script src=\"../../site_libs/rglwidgetClass-1.3.1/init.src.js\"></script>\n<script src=\"../../site_libs/rglwidgetClass-1.3.1/pieces.src.js\"></script>\n<script src=\"../../site_libs/rglwidgetClass-1.3.1/draw.src.js\"></script>\n<script src=\"../../site_libs/rglwidgetClass-1.3.1/controls.src.js\"></script>\n<script src=\"../../site_libs/rglwidgetClass-1.3.1/selection.src.js\"></script>\n<script src=\"../../site_libs/rglwidgetClass-1.3.1/rglTimer.src.js\"></script>\n<script src=\"../../site_libs/rglwidgetClass-1.3.1/pretty.src.js\"></script>\n<script src=\"../../site_libs/rglwidgetClass-1.3.1/axes.src.js\"></script>\n<script src=\"../../site_libs/rglwidgetClass-1.3.1/animation.src.js\"></script>\n<script src=\"../../site_libs/CanvasMatrix4-1.3.1/CanvasMatrix.src.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}